<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lambda Dependency-Based Compositional Semantics | Your awesome title</title>
    <link rel="stylesheet" href="/assets/css/style.css">
    <!-- Add MathJax script here -->
    <script type="text/javascript"
            async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js">
    </script>
    <script type="text/javascript">
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        }
      };
    </script>
  </head>
  <body>
    <header>
      <h1>Your awesome title</h1>
    </header>
    <main>
      <article>
  <header>
    <h1>Lambda Dependency-Based Compositional Semantics</h1>
    <p>29 Jan 2023</p>
  </header>
  <section>
    <blockquote>
  <p>Lambda DCS is a kind of formal language to query the knowledge base. It has simplified expressions compared to lambda calculus, due to elimination of variables and making of implicit existential quantifications. We briefly list the fundamentals here by examples comparing with lambda calculus.</p>
</blockquote>

<ul>
  <li>Semantic parsing is the task of transforming the natural utterances into the logical forms. Those forms are in some of formal language such as  $\lambda-$ calculus. So is  $\lambda-$ DCS.</li>
  <li>lambda DCS was designed to query the Freebase.</li>
</ul>

<h2 id="fundamentals">Fundamentals</h2>

<ul>
  <li>
    <p>We have a knowledge base of assertions, namely $\mathcal{K}$ , a set of entities(nodes) $\mathcal{E}$ , a set of properties (edges) $\mathcal{P}$ , then we have $\mathcal{K}\subset \mathcal{E}\times \mathcal{P}\times \mathcal{E}$ .</p>
  </li>
  <li>We let [condition] denotes the truth value of the condition. ( $\lambda x.[x=3]$ ) denotes the function returns true if and only if x=3.</li>
  <li>We let $\textlbrackdbl z \textrbrackdbl$ be the lambda DCS corresponded to the lambda calculus of z.</li>
</ul>

<h4 id="unary-base-case">Unary base case</h4>

<p>a simple entity in lamdba DCS:</p>

\[Seattle\Longleftrightarrow\lambda x.[x=Seattle] \\
\textlbrackdbl e \textrbrackdbl = \lambda x.[x=e]\]

<h3 id="binary-base-case">Binary base case</h3>

<p>For a property $p\in \mathcal{P}$  ,  p is a binary logical form, which denotes a function mapping two arguments to whether p holds:</p>

\[PlaceOfBirth \Longleftrightarrow \lambda x.\lambda y.PlaceOfBirth(x, y)\\
\textlbrackdbl p\textrbrackdbl = \lambda x.\lambda y.p(x, y)\]

<h3 id="join-">Join *</h3>

\[PlaceOfBirth.Seattle \Longleftrightarrow \lambda x.PlaceOfBirth(x, Seattle) \\
\textlbrackdbl b.u \textrbrackdbl = \lambda x.\exists y. \textlbrackdbl b \textrbrackdbl(x,y)\and \textlbrackdbl u \textrbrackdbl(y)\]

<p>where b is a binary logical form and u is a unary logical form, and b.u is a unary logical form.</p>

<p><strong>This is a key feature of join (the central operation of lambda DCS). Implicit existential quantification over argument y shared by b and u. This makes it more apparent when binaries are chained.</strong></p>

<h3 id="intersection">Intersection</h3>

<p>a set of scientists born in Seattle:</p>

\[Profession.Scientists \sqcap PlaceOfBirth.Seattle\\
\Longleftrightarrow\\
\lambda x. Profession(x,Scientist)\and PlaceOfBirth(x, Seattle)\\
\textlbrackdbl u_1\sqcap u_2 \textrbrackdbl = \lambda x.\textlbrackdbl u_1 \textrbrackdbl(x)\and\textlbrackdbl u_2 \textrbrackdbl(x)\]

<p>From the perspective of graph pattern, intersection allow tree-structured graph patterns, where branch points correspond to the intersections.</p>

<h3 id="union">Union</h3>

<p>Intersection corresponds to conjunction, union corresponds to disjunction.</p>

\[Oregon \sqcup Washington \Longleftrightarrow \lambda x.[x=Oregon]\or [x=Washington]\\
\textlbrackdbl u_1\sqcup u_2 \textrbrackdbl = \lambda x.\textlbrackdbl u_1 \textrbrackdbl(x)\or\textlbrackdbl u_2 \textrbrackdbl(x)\]

<h3 id="negation">Negation</h3>

<p>US states not bordering California</p>

\[Type.USState\sqcap \neg Border.California\\
\Longleftrightarrow \lambda x.Type(x, USState)\and \neg Border(x, California)\\
\textlbrackdbl \neg u \textrbrackdbl = \lambda x.\neg\textlbrackdbl u \textrbrackdbl(x)\]


  </section>
</article>

    </main>
    <footer>
      <p>&copy; 2024 Your awesome title</p>
    </footer>
  </body>
</html>
